# 词法分析+LR（1）语法分析
编译原理，词法分析器和语法分析器的实现（C++）

## 任务一：词法分析程序
文法参考C++词法规则，支持关键字、标识符、常量（字符、字符串、数值）、界符和运算符的识别，可识别科学计数法形式和复数形式的常量，可检查数值是否超出范围，以及标识符的合法性。

### 1、	词法分析文法（文法.txt）
第一行数字为文法条数，最后一条文法为Y->@，Y为结束状态，@表示空。
A、B、C、D分别表示界符、运算符、标识符、数值常量，关键字使用字符串数组存储，字符和字符串形式（包括转义符的识别）的常量利用成对引号进行识别。

### 2、	数据结构
VNimf为非终结符（状态）信息，包括非终结符vn、可能的输入符号next、可能的输入符号数目n、每个输入符号对应的下一个状态end。
定义VNimf数组VN[100]。

subset为子集信息，包括子集内含的非终结符t、可能的输入符号next、输入符号对应的开始状态start和下一个状态end。
定义subset数组Ti[1000]。

Token为token表中项目信息，包括识别到的词t、词语初次分析的类别type、词语最终类别Type、词语在源代码中的行号line、词语是否为可用于定义的关键字isDef。
定义Token数组token[1000]。
 

### 3、	NFA构造
 
* 第一步：首先添加开始状态X：
 
* 第二步：将文法文本转换为状态信息：
		按行读取产生式
		如果文法产生式左端非终结符不是第一次被读取，则在VN[100]中对应的非终结符下添加产生式信息，否则在VN[100]中添加该非终结符并添加产生式信息。
		如果产生式字符串长度为5，则读取末尾字母为下一个状态；如果产生式字符串长度为4，则下一个状态为Y。

### 4、	DFA构造
 
（用到了两个主要函数closure(子集序号)和closureMove(前一个子集序号，终结符，当前子集序号)，前一个函数在扩充子集后调用order函数对子集内字符进行排序；后一个函数先move（前一个子集序号，终结符），再调用closure函数进行子集扩充。）
nontip为未标记子集个数

* 第一步：用开始状态X作为第0个子集，调用closure(0)进行扩充，nontip=1。

* 第二步：当nontip!=0时，循环构造DFA，从第0个子集开始，对每个子集使用所有终结符调用closureMove函数，调用完成后将当前子集和之前构造完成的所有子集进行比对，如果存在相同子集，则当前子集清空，nontip保持不变，若不存在则nontip加一。
每标记完成一个子集nontip减一。
 
### 5、	读取源程序文本，进行词法分析
 
（用到了函数jud(空格分割后的字符串，当前token表项目序号，源程序中对应行号)，该函数逐个读入字符，首先将字符转换为可识别的终结符号，

从第0个子集开始，如果当前子集已经包含Y状态，则判断当前子集是否可以通过当前终结符转入下一个子集，若可以，则继续识别；

若不能，则判断当前字符串（当前字符串：上一次识别到Y状态的字符索引一直到当前字符）是否为关键字以及基本类型关键字（防止标识符和关键字冲突），继续判断字符串是否已识别完成，若识别完成，则返回当前token表项目序号；

若未识别完成，并且上一个词为引号，则进行字符或字符串的识别，然后继续逐个读入字符，并将字符转换为可识别的终结符号，转入下一个子集。

如果字符串已全部读入但函数仍未返回，则将当前字符串判定为出错然后返回当前token表项目序号。）

* 第一步：按行读取文本，以空格分割字符串存入tem，
如果tem是关键字，更新token表信息（同时判断tem是否为基本类型关键字），进行下一个词的分析。
如果tem不是关键字，调用jud函数，判断其类别，需要注意的是，空格分割后的字符串可能包含不止一个词语。

* 第二步：处理token表中有争议的词语类别
（第一步分析后某些词语的类别可能不止一个）。
如果词语类别中同时存在界符和运算符（本程序中可能的冲突只有<和>），则利用前后相邻词语类别进行取舍，如果前后均为标识符或常量，则判定为运算符，否则为界符；
如果词语类别中同时存在运算符和数值常量，则如果词语第二个字符为数字，判定为数值常量，否则为运算符。
如果词语为数值常量，则判断数值大小是否超过范围。
 
* 第三步：处理标识符出错情况，循环遍历token表，如果前一个词语为基本类型关键字，则从当前词语开始，检查标识符的合法性。代码见下图。
 



## 任务二、LR（1）语法分析
文法参考C++语法规则，可判断语句是否符合文法，输出yes或no，如果不符合，同时输出当前符号所在token表行号、当前符号栈内容、出错时ACTION表中对应的行状态和列终结符。

ACTION和GOTO表如下图：
![1](https://user-images.githubusercontent.com/100982395/186348773-e9c59457-596d-46e6-a530-b6c6781bfbb6.png)
由于ACTION表和GOTO表较大，中间部分省略
![2](https://user-images.githubusercontent.com/100982395/186348928-11d16ff6-d1c6-4988-9d6f-9a6b6c92be46.png)


### 1、	语法分析文法（语法分析_2型文法.txt）
第一行为文法产生式数目 
非终结符和语法结构对应关系如下：
![3](https://user-images.githubusercontent.com/100982395/186349380-c724fa8e-c155-4fe6-a35c-bbc05ae2d152.png)

终结符和实际字符对应关系如下（词法分析中可能的词法错误不计入语法分析，错误的标识符和常量仅识别为对应类别）：
![4](https://user-images.githubusercontent.com/100982395/186349462-2148ffc8-faef-48dd-bc2d-8ccc9fb7ffe2.png)



### 2、	数据结构
Prod为文法产生式信息，包括产生式左端非终结符Vn、产生式右端字符串right。
定义Prod数组P[100]。

Item为为项目信息，包括左端非终结符Vn、圆点左部字符串left、圆点右部字符串right、向前搜索符ahead。
Itemset为项目集信息，包括项目集内项目数组（即Item数组item[200]）、可能的前一个移进符号pre、前一个移进符号对应的前一个项目集序号数组preI[200]、可能的下一个移进符号next、下一个移进符号对应的下一个项目集序号数组nextI[200]、项目集内项目个数n。
定义Itemset数组I[2000]。
ACTION为ACTION表中一列（即终结符对应的所有状态的动作）的信息，包括状态对应的动作（S或r或A）数组a[2000]、动作对应的下一个状态或产生式序号数组aI[2000]。
定义ACTION数组ACTION[100]。

GOTO为GOTO表中一列的信息，包括状态对应的下一个状态数组n[2000]。
 


### 3、	获取产生式信息
 
* 第一步：添加扩展式Z->S
* 第二步：逐行读入产生式，并将产生式按字符串大小升序排列，更新产生式数组。

### 4、	构造项目集
 
（用到了两个主要函数closure(项目集序号)和go(前一个项目集序号，移进符号，当前项目集序号)。

closure函数用于扩充项目集，如果项目A->α·Bβ, a属于项目集I，B->γ是文法产生式，β∈V *，b∈FIRST（βα），并且B->·γ, b尚未在项目集I中，则用项目B->·γ, b更新项目集I。同时更新项目集可能的移进符号。

go函数用于移进符号构造新的项目集，移进完成后调用closure函数扩充项目集，再对项目集内项目排序，按字符串从小到大进行排列，最后将该项目集和之前所有项目集进行比较，如果已存在相同项目集，则将当前项目集所有信息清空。）

* 第一步：将扩展式添加到第0个项目集，调用closure(0)。

* 第二步：从第0个项目集开始，对每一个可能的移进符号调用go函数，直到没有新的项目集产生为止。

### 5、	构造ACTION表和GOTO表
 
遍历项目集族，
* 第一步：对当前项目集的所有可能的移进符号逐个分析，如果该移进符号是终结符，则用‘S’和下一个状态序号更新ACTION表对应元素，否则，用移进符号的对应下一个项目集序号更新GOTO表对应元素。

* 第二步：对当前项目集的所有项目逐条分析，如果该项目为Z->S·, @，则用‘A’更新ACTION表对应元素。（@表示空）如果该项目右端圆点右没有符号，则用‘r’ 和对应产生式序号更新ACTION表对应动作。

### 6、	语法分析
 
（用到了一个主要函数analyse(转换后的终结符字符串，上次语法分析完成后的字符索引)。

输入串末尾添加@字符，当输入串不为空时，读取输入串第一个字符，
从第0个状态开始，找到ACTION/GOTO表中对应列的对应元素，如果该元素为空，表示出错，输出出错信息并返回；如果该元素为‘A’，则输出“yes”，若输入串中仍有字符，继续调用analyse函数，返回；如果该元素为‘S’，将字符移入符号栈，下一个状态移入状态栈，输入串删除第一个字符；如果该元素为‘r’，则用对应产生式进行归约。
如果输入串读取完毕仍未返回，则输入“no”并返回。）

按行读取token表，
* 第一步：将词语转换为可识别的终结字符。
（其中，for循环小括号中的语句特殊处理，在第三条语句后增加分号；头文件语句一经转换立即识别。）
* 第二步：如果遇到分号或成对的大括号，调用analyse函数进行语法分析。
